import 'package:bcrypt/bcrypt.dart' show BCrypt;
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:pharmacie_stock/models/user.dart';
import 'package:pharmacie_stock/repositories/users.dart';

enum AuthStatus {
  unauthenticated,
  authenticating,
  authenticated,
  authenticationFailed,
}

class AuthProvider extends ChangeNotifier {
  final UserRepository _userRepository;
  User? _currentUser;
  AuthStatus _status = AuthStatus.unauthenticated;
  String? _errorMessage;

  AuthProvider(this._userRepository);

  User? get currentUser => _currentUser;
  AuthStatus get status => _status;
  String? get errorMessage => _errorMessage;
  bool get isAuthenticated => _status == AuthStatus.authenticated;
  bool get isAdmin => _currentUser?.role == UserRole.admin;

  /// Checks if user has specific permission.
  bool hasPermission(PermissionType permission) {
    return _currentUser?.permissions.contains(permission) ?? false;
  }

  // Login with email and password
  Future<bool> login(String email, String password) async {
    _setStatus(AuthStatus.authenticating);
    _errorMessage = null;

    try {
      final user = await _userRepository.getUserByEmail(email);

      if (user == null) {
        _setError('User not found');
        return false;
      }

      if (BCrypt.checkpw(password, user.passwordHash)) {
        _setError('Invalid password');
        return false;
      }

      _currentUser = user;
      _setStatus(AuthStatus.authenticated);

      // Update last login time
      await _userRepository.updateUser(
        user.copyWith(lastLogin: DateTime.now().toUtc().toString()),
      );

      return true;
    } catch (e) {
      _setError('Login failed: ${e.toString()}');
      return false;
    }
  }

  // Logout
  Future<void> logout() async {
    _currentUser = null;
    _setStatus(AuthStatus.unauthenticated);
    _errorMessage = null;
  }

  // Register a new user (admin only)
  Future<bool> register({
    required String name,
    required String email,
    required String password,
    required UserRole role,
    required List<PermissionType> permissions,
  }) async {
    // if (!isAdmin) {
    //   _setError('Only admins can register new users');
    //   return false;
    // }

    _setStatus(AuthStatus.authenticating);
    _errorMessage = null;

    try {
      // Check if user already exists
      final existingUser = await _userRepository.getUserByEmail(email);
      if (existingUser != null) {
        _setError('User with this email already exists');
        return false;
      }

      // Create new user
      final newUser = User(
        id: '', // Will be generated by repository
        name: name,
        email: email,
        role: role,
        permissions: permissions,
        passwordHash: _hashPassword(password),
        createdAtInUtc: DateTime.now().toUtc(),
        lastLogin: null,
      );

      await _userRepository.createUser(newUser);
      return true;
    } catch (e) {
      _setError('Registration failed: ${e.toString()}');
      return false;
    } finally {
      _setStatus(
        isAuthenticated ? AuthStatus.authenticated : AuthStatus.unauthenticated,
      );
    }
  }

  // Change password
  Future<bool> changePassword(String oldPassword, String newPassword) async {
    if (_currentUser == null) return false;

    // Verify old password
    if (_currentUser!.passwordHash != _hashPassword(oldPassword)) {
      _setError('Current password is incorrect');
      return false;
    }

    try {
      await _userRepository.updateUser(
        _currentUser!.copyWith(passwordHash: _hashPassword(newPassword)),
      );
      return true;
    } catch (e) {
      _setError('Failed to change password: ${e.toString()}');
      return false;
    }
  }

  // Helper methods
  void _setStatus(AuthStatus status) {
    _status = status;
    notifyListeners();
  }

  void _setError(String message) {
    _errorMessage = message;
    _status = AuthStatus.authenticationFailed;
    notifyListeners();
  }

  String _hashPassword(String password) {
    return BCrypt.hashpw(password, BCrypt.gensalt());
  }

  // Load user from persistent storage on app start
  Future<void> loadPersistedUser() async {
    _setStatus(AuthStatus.authenticating);

    // Implement your persistence logic here
    // For example, using shared_preferences to store user ID
    // final prefs = await SharedPreferences.getInstance();
    // final userId = prefs.getString('userId');

    // if (userId != null) {
    //   final user = await _userRepository.getUser(userId);
    //   if (user != null) {
    //     _currentUser = user;
    //     _setStatus(AuthStatus.authenticated);
    //     return;
    //   }
    // }

    _setStatus(AuthStatus.unauthenticated);
  }
}
